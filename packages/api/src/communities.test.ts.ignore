import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { renderHook, waitFor } from '@testing-library/react';
import { faker } from '@faker-js/faker';
import {
  fetchCommunities,
  fetchCommunityById,
  createCommunity,
  updateCommunity,
  deleteCommunity,
} from './communities/api';
import {
  useCommunities,
  useCommunity,
  useCreateCommunity,
  useUpdateCommunity,
  useDeleteCommunity,
} from '../hooks/communities';
import {
  createMockCommunity,
  createMockDbCommunity,
  createMockUser,
} from '../test-utils/mocks';
import { ReactQueryWrapper } from '../test-utils/test-utils';
import type {
  CreateCommunityData,
  UpdateCommunityData,
} from '@belongnetwork/types';
import { supabase, logger } from '@belongnetwork/core';

// Mock dependencies
vi.mock('@belongnetwork/core', () => ({
  supabase: {
    auth: {
      getUser: vi.fn(),
    },
    from: vi.fn(() => ({
      select: vi.fn(() => ({
        order: vi.fn(),
        eq: vi.fn(() => ({
          single: vi.fn(),
          eq: vi.fn(() => ({
            select: vi.fn(() => ({
              single: vi.fn(),
            })),
          })),
        })),
        single: vi.fn(),
      })),
      insert: vi.fn(() => ({
        select: vi.fn(() => ({
          single: vi.fn(),
        })),
      })),
      update: vi.fn(() => ({
        eq: vi.fn(() => ({
          eq: vi.fn(() => ({
            select: vi.fn(() => ({
              single: vi.fn(),
            })),
          })),
        })),
      })),
      delete: vi.fn(() => ({
        eq: vi.fn(() => ({
          eq: vi.fn(),
        })),
      })),
    })),
  },
  logger: {
    debug: vi.fn(),
    info: vi.fn(),
    warn: vi.fn(),
    error: vi.fn(),
  },
}));

const mockSupabase = vi.mocked(supabase);
const mockLogger = vi.mocked(logger);

describe('Community Functions', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  afterEach(() => {
    vi.resetAllMocks();
  });

  describe('fetchCommunities', () => {
    it('should successfully fetch communities', async () => {
      // Arrange
      const mockDbCommunities = Array.from({ length: 3 }, () =>
        createMockDbCommunity()
      );

      const mockQuery = {
        select: vi.fn().mockReturnValue({
          order: vi.fn().mockResolvedValue({
            data: mockDbCommunities,
            error: null,
          }),
        }),
      } as any;

      mockSupabase.from.mockReturnValue(mockQuery);

      // Act
      const result = await fetchCommunities();

      // Assert
      expect(mockSupabase.from).toHaveBeenCalledWith('communities');
      expect(result).toHaveLength(3);
      expect(result[0]).toMatchObject({
        id: expect.any(String),
        name: expect.any(String),
        organizer: expect.objectContaining({
          id: expect.any(String),
          email: expect.any(String),
        }),
      });
      expect(mockLogger.debug).toHaveBeenCalledWith(
        'ğŸ˜ï¸ API: Successfully fetched communities',
        { count: 3 }
      );
    });

    it('should handle database errors', async () => {
      // Arrange
      const dbError = new Error('Database connection failed');
      const mockQuery = {
        select: vi.fn().mockReturnValue({
          order: vi.fn().mockResolvedValue({
            data: null,
            error: dbError,
          }),
        }),
      } as any;

      mockSupabase.from.mockReturnValue(mockQuery);

      // Act & Assert
      await expect(fetchCommunities()).rejects.toThrow(
        'Database connection failed'
      );
      expect(mockLogger.error).toHaveBeenCalledWith(
        'ğŸ˜ï¸ API: Failed to fetch communities',
        { error: dbError }
      );
    });
  });

  describe('fetchCommunityById', () => {
    it('should successfully fetch a community by ID', async () => {
      // Arrange
      const mockDbCommunity = createMockDbCommunity();
      const communityId = mockDbCommunity.id;

      const mockQuery = {
        select: vi.fn().mockReturnValue({
          eq: vi.fn().mockReturnValue({
            single: vi.fn().mockResolvedValue({
              data: mockDbCommunity,
              error: null,
            }),
          }),
        }),
      } as any;

      mockSupabase.from.mockReturnValue(mockQuery);

      // Act
      const result = await fetchCommunityById(communityId);

      // Assert
      expect(mockSupabase.from).toHaveBeenCalledWith('communities');
      expect(result).toMatchObject({
        id: communityId,
        name: mockDbCommunity.name,
      });
      expect(mockLogger.debug).toHaveBeenCalledWith(
        'ğŸ˜ï¸ API: Successfully fetched community',
        { id: communityId, name: result?.name }
      );
    });

    it('should return null when community is not found', async () => {
      // Arrange
      const communityId = faker.string.uuid();
      const notFoundError = { code: 'PGRST116' };

      const mockQuery = {
        select: vi.fn().mockReturnValue({
          eq: vi.fn().mockReturnValue({
            single: vi.fn().mockResolvedValue({
              data: null,
              error: notFoundError,
            }),
          }),
        }),
      } as any;

      mockSupabase.from.mockReturnValue(mockQuery);

      // Act
      const result = await fetchCommunityById(communityId);

      // Assert
      expect(result).toBeNull();
    });

    it('should throw error for database errors', async () => {
      // Arrange
      const communityId = faker.string.uuid();
      const dbError = new Error('Database query failed');

      const mockQuery = {
        select: vi.fn().mockReturnValue({
          eq: vi.fn().mockReturnValue({
            single: vi.fn().mockResolvedValue({
              data: null,
              error: dbError,
            }),
          }),
        }),
      } as any;

      mockSupabase.from.mockReturnValue(mockQuery);

      // Act & Assert
      await expect(fetchCommunityById(communityId)).rejects.toThrow(
        'Database query failed'
      );
      expect(mockLogger.error).toHaveBeenCalledWith(
        'ğŸ˜ï¸ API: Error fetching community by ID',
        { id: communityId, error: dbError }
      );
    });
  });

  describe('createCommunity', () => {
    it('should successfully create a community', async () => {
      // Arrange
      const mockUser = createMockUser();
      const createData: CreateCommunityData = {
        name: 'Test Community',
        description: 'A test community for unit testing',
        center: { lat: 40.7128, lng: -74.006 },
        radius_km: 5,
        parent_id: faker.string.uuid(),
      };

      const mockDbCommunity = createMockDbCommunity({
        ...createData,
        organizer_id: mockUser.id,
      });

      mockSupabase.auth.getUser = vi.fn().mockResolvedValue({
        data: { user: { id: mockUser.id } },
        error: null,
      });

      const mockQuery = {
        insert: vi.fn().mockReturnValue({
          select: vi.fn().mockReturnValue({
            single: vi.fn().mockResolvedValue({
              data: mockDbCommunity,
              error: null,
            }),
          }),
        }),
      } as any;

      mockSupabase.from.mockReturnValue(mockQuery);

      // Act
      const result = await createCommunity(createData);

      // Assert
      expect(mockSupabase.from).toHaveBeenCalledWith('communities');
      expect(result).toMatchObject({
        name: createData.name,
        description: createData.description,
      });
      expect(mockLogger.info).toHaveBeenCalledWith(
        'ğŸ˜ï¸ API: Successfully created community',
        { id: result.id, name: result.name }
      );
    });

    it('should require authentication to create community', async () => {
      // Arrange
      const createData: CreateCommunityData = {
        name: 'Test Community',
        description: 'A test community for unit testing',
        parent_id: faker.string.uuid(),
      };

      mockSupabase.auth.getUser = vi.fn().mockResolvedValue({
        data: { user: null },
        error: null,
      });

      // Act & Assert
      await expect(createCommunity(createData)).rejects.toThrow(
        'User must be authenticated to perform this operation'
      );
    });

    it('should handle creation errors', async () => {
      // Arrange
      const mockUser = createMockUser();
      const createData: CreateCommunityData = {
        name: 'Test Community',
        description: 'A test community for unit testing',
        parent_id: faker.string.uuid(),
      };
      const createError = new Error('Creation failed');

      mockSupabase.auth.getUser = vi.fn().mockResolvedValue({
        data: { user: { id: mockUser.id } },
        error: null,
      });

      const mockQuery = {
        insert: vi.fn().mockReturnValue({
          select: vi.fn().mockReturnValue({
            single: vi.fn().mockResolvedValue({
              data: null,
              error: createError,
            }),
          }),
        }),
      } as any;

      mockSupabase.from.mockReturnValue(mockQuery);

      // Act & Assert
      await expect(createCommunity(createData)).rejects.toThrow(
        'Creation failed'
      );
      expect(mockLogger.error).toHaveBeenCalledWith(
        'ğŸ˜ï¸ API: Failed to create community',
        { error: createError }
      );
    });
  });

  describe('updateCommunity', () => {
    it('should successfully update a community', async () => {
      // Arrange
      const mockUser = createMockUser();
      const updateData: UpdateCommunityData = {
        id: faker.string.uuid(),
        name: 'Updated Community',
        description: 'Updated description',
      };

      const mockDbCommunity = createMockDbCommunity({
        id: updateData.id,
        name: updateData.name,
        description: updateData.description,
        organizer_id: mockUser.id,
      });

      mockSupabase.auth.getUser = vi.fn().mockResolvedValue({
        data: { user: { id: mockUser.id } },
        error: null,
      });

      const mockQuery = {
        update: vi.fn().mockReturnValue({
          eq: vi.fn().mockReturnValue({
            eq: vi.fn().mockReturnValue({
              select: vi.fn().mockReturnValue({
                single: vi.fn().mockResolvedValue({
                  data: mockDbCommunity,
                  error: null,
                }),
              }),
            }),
          }),
        }),
      } as any;

      mockSupabase.from.mockReturnValue(mockQuery);

      // Act
      const result = await updateCommunity(updateData);

      // Assert
      expect(mockSupabase.from).toHaveBeenCalledWith('communities');
      expect(result).toMatchObject({
        id: updateData.id,
        name: updateData.name,
        description: updateData.description,
      });
      expect(mockLogger.info).toHaveBeenCalledWith(
        'ğŸ˜ï¸ API: Successfully updated community',
        { id: result.id, name: result.name }
      );
    });

    it('should require authentication to update community', async () => {
      // Arrange
      const updateData: UpdateCommunityData = {
        id: faker.string.uuid(),
        name: 'Updated Community',
      };

      mockSupabase.auth.getUser = vi.fn().mockResolvedValue({
        data: { user: null },
        error: null,
      });

      // Act & Assert
      await expect(updateCommunity(updateData)).rejects.toThrow(
        'User must be authenticated to perform this operation'
      );
    });
  });

  describe('deleteCommunity', () => {
    it('should successfully delete a community', async () => {
      // Arrange
      const mockUser = createMockUser();
      const communityId = faker.string.uuid();

      mockSupabase.auth.getUser = vi.fn().mockResolvedValue({
        data: { user: { id: mockUser.id } },
        error: null,
      });

      const mockQuery = {
        delete: vi.fn().mockReturnValue({
          eq: vi.fn().mockReturnValue({
            eq: vi.fn().mockResolvedValue({
              error: null,
            }),
          }),
        }),
      } as any;

      mockSupabase.from.mockReturnValue(mockQuery);

      // Act
      await deleteCommunity(communityId);

      // Assert
      expect(mockSupabase.from).toHaveBeenCalledWith('communities');
      expect(mockQuery.delete().eq().eq).toHaveBeenCalledWith(
        'organizer_id',
        mockUser.id
      );
      expect(mockLogger.info).toHaveBeenCalledWith(
        'ğŸ˜ï¸ API: Successfully deleted community',
        { id: communityId }
      );
    });

    it('should require authentication to delete community', async () => {
      // Arrange
      const communityId = faker.string.uuid();

      mockSupabase.auth.getUser = vi.fn().mockResolvedValue({
        data: { user: null },
        error: null,
      });

      // Act & Assert
      await expect(deleteCommunity(communityId)).rejects.toThrow(
        'User must be authenticated to perform this operation'
      );
    });
  });
});

describe('Community Hooks', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  afterEach(() => {
    vi.resetAllMocks();
  });

  describe('useCommunities', () => {
    it('should fetch communities successfully', async () => {
      // Arrange
      const mockDbCommunities = Array.from({ length: 2 }, () =>
        createMockDbCommunity()
      );

      const mockQuery = {
        select: vi.fn().mockReturnValue({
          order: vi.fn().mockResolvedValue({
            data: mockDbCommunities,
            error: null,
          }),
        }),
      } as any;

      mockSupabase.from.mockReturnValue(mockQuery);

      // Act
      const { result } = renderHook(() => useCommunities(), {
        wrapper: ReactQueryWrapper,
      });

      // Assert
      await waitFor(() => {
        expect(result.current.isSuccess).toBe(true);
      });
      expect(result.current.data).toHaveLength(2);
    });
  });

  describe('useCommunity', () => {
    it('should fetch single community successfully', async () => {
      // Arrange
      const mockDbCommunity = createMockDbCommunity();
      const communityId = mockDbCommunity.id;

      const mockQuery = {
        select: vi.fn().mockReturnValue({
          eq: vi.fn().mockReturnValue({
            single: vi.fn().mockResolvedValue({
              data: mockDbCommunity,
              error: null,
            }),
          }),
        }),
      } as any;

      mockSupabase.from.mockReturnValue(mockQuery);

      // Act
      const { result } = renderHook(() => useCommunity(communityId), {
        wrapper: ReactQueryWrapper,
      });

      // Assert
      await waitFor(() => {
        expect(result.current.isSuccess).toBe(true);
      });
      expect(result.current.data).toMatchObject({
        id: communityId,
        name: mockDbCommunity.name,
      });
    });

    it('should not fetch when id is empty', () => {
      // Act
      const { result } = renderHook(() => useCommunity(''), {
        wrapper: ReactQueryWrapper,
      });

      // Assert
      expect(result.current.isPending).toBe(true);
      expect(mockSupabase.from).not.toHaveBeenCalled();
    });
  });

  describe('useCreateCommunity', () => {
    it('should create community and invalidate cache', async () => {
      // Arrange
      const mockUser = createMockUser();
      const createData: CreateCommunityData = {
        name: 'Test Community',
        description: 'A test community for unit testing',
        parent_id: faker.string.uuid(),
      };

      const mockDbCommunity = createMockDbCommunity({
        ...createData,
        organizer_id: mockUser.id,
      });

      mockSupabase.auth.getUser = vi.fn().mockResolvedValue({
        data: { user: { id: mockUser.id } },
        error: null,
      });

      const mockQuery = {
        insert: vi.fn().mockReturnValue({
          select: vi.fn().mockReturnValue({
            single: vi.fn().mockResolvedValue({
              data: mockDbCommunity,
              error: null,
            }),
          }),
        }),
      } as any;

      mockSupabase.from.mockReturnValue(mockQuery);

      // Act
      const { result } = renderHook(() => useCreateCommunity(), {
        wrapper: ReactQueryWrapper,
      });

      result.current.mutate(createData);

      // Assert
      await waitFor(() => {
        expect(result.current.isSuccess).toBe(true);
      });
      expect(mockLogger.info).toHaveBeenCalledWith(
        'ğŸ˜ï¸ API: Community created successfully',
        { id: expect.any(String) }
      );
    });

    it('should handle creation errors', async () => {
      // Arrange
      const createData: CreateCommunityData = {
        name: 'Test Community',
        description: 'A test community for unit testing',
        parent_id: faker.string.uuid(),
      };

      mockSupabase.auth.getUser = vi.fn().mockResolvedValue({
        data: { user: null },
        error: null,
      });

      // Act
      const { result } = renderHook(() => useCreateCommunity(), {
        wrapper: ReactQueryWrapper,
      });

      result.current.mutate(createData);

      // Assert
      await waitFor(() => {
        expect(result.current.isError).toBe(true);
      });
      expect(mockLogger.error).toHaveBeenCalledWith(
        'ğŸ˜ï¸ API: Failed to create community',
        { error: expect.any(Error) }
      );
    });
  });

  describe('useUpdateCommunity', () => {
    it('should update community and invalidate cache', async () => {
      // Arrange
      const mockUser = createMockUser();
      const updateData: UpdateCommunityData = {
        id: faker.string.uuid(),
        name: 'Updated Community',
      };

      const mockDbCommunity = createMockDbCommunity({
        id: updateData.id,
        name: updateData.name,
        organizer_id: mockUser.id,
      });

      mockSupabase.auth.getUser = vi.fn().mockResolvedValue({
        data: { user: { id: mockUser.id } },
        error: null,
      });

      const mockQuery = {
        update: vi.fn().mockReturnValue({
          eq: vi.fn().mockReturnValue({
            eq: vi.fn().mockReturnValue({
              select: vi.fn().mockReturnValue({
                single: vi.fn().mockResolvedValue({
                  data: mockDbCommunity,
                  error: null,
                }),
              }),
            }),
          }),
        }),
      } as any;

      mockSupabase.from.mockReturnValue(mockQuery);

      // Act
      const { result } = renderHook(() => useUpdateCommunity(), {
        wrapper: ReactQueryWrapper,
      });

      result.current.mutate(updateData);

      // Assert
      await waitFor(() => {
        expect(result.current.isSuccess).toBe(true);
      });
      expect(mockLogger.info).toHaveBeenCalledWith(
        'ğŸ˜ï¸ API: Community updated successfully',
        { id: expect.any(String) }
      );
    });
  });

  describe('useDeleteCommunity', () => {
    it('should delete community and invalidate cache', async () => {
      // Arrange
      const mockUser = createMockUser();
      const communityId = faker.string.uuid();

      mockSupabase.auth.getUser = vi.fn().mockResolvedValue({
        data: { user: { id: mockUser.id } },
        error: null,
      });

      const mockQuery = {
        delete: vi.fn().mockReturnValue({
          eq: vi.fn().mockReturnValue({
            eq: vi.fn().mockResolvedValue({
              error: null,
            }),
          }),
        }),
      } as any;

      mockSupabase.from.mockReturnValue(mockQuery);

      // Act
      const { result } = renderHook(() => useDeleteCommunity(), {
        wrapper: ReactQueryWrapper,
      });

      result.current.mutate(communityId);

      // Assert
      await waitFor(() => {
        expect(result.current.isSuccess).toBe(true);
      });
      expect(mockLogger.info).toHaveBeenCalledWith(
        'ğŸ˜ï¸ API: Community deleted successfully',
        { id: communityId }
      );
    });
  });
});
